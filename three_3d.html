<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
	<meta charset="UTF-8">
	<title>3dテスト</title>
</head>
<body>
<!-- 	<canvas id="c"></canvas> -->
</body>
<script type="module">
import * as THREE from '../three/build/three.module.js';
import {OrbitControls} from '../three/examples/jsm/controls/OrbitControls.js';
import {OBJLoader} from '../three/examples/jsm/loaders/OBJLoader.js';
import {MTLLoader} from '../three/examples/jsm/loaders/MTLLoader.js';

let width = window.innerWidth;
let height = window.innerHeight;

document.body.insertAdjacentHTML("afterbegin","<div id='stage'></div>");
const stage = document.getElementById("stage");

let mode = "3d"; //3dモデルかstreet viewか

/* ↓------------------------------ 3dモデル用のscene作成-------------------------------------------*/
const scene = new THREE.Scene();
scene.background = new THREE.Color('skyblue');
scene.name = undefined;
//カメラ
const camera = new THREE.PerspectiveCamera(75, width/height, 0.01, 1000);
camera.position.set(0, 100, 80);
scene.add(camera);

//地面
{
    const planeSize = 512;

    //画像
    const texture = new THREE.TextureLoader().load('./images/grass.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.LinearMipmapLinearFilter;
    //planeSize/2回リピート
    const repeats = planeSize / 64;
    texture.repeat.set(repeats, repeats);

    //平面のジオメトリ
    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    //マテリアル
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide //両面描画
    });
    //合成してメッシュ
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    mesh.position.y -= 0.4;
    //sceneに追加
    scene.add(mesh);
}

//半球光源 追加
{
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xcd853f;  // brownish orange
    const intensity = 0.7;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
}

//平行光源 追加
{
    const color = 0xFFFFFF;
    const intensity = 0.8;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(5, 10, 2);
    scene.add(light);
    // scene.add(light.target);
}

//外側の球
{
    const loader = new THREE.TextureLoader();
    loader.load('https://82mou.github.io/threejs/img/earth.jpg', function(texture) {
        const geometry = new THREE.SphereGeometry(250, 32, 32);
        geometry.scale(-1, 1, 1);
        const material =  new THREE.MeshLambertMaterial({map: texture});
        const sphere = new THREE.Mesh( geometry, material);
        scene.add( sphere );
    });
}
/*↑____________________________ここまで3d用scene__________________________________________________*/

/*↓----------------------------ストリートビュー用のscene作成------------------------------------------*/
const street_scene = new THREE.Scene();
street_scene.background = new THREE.Color('black');
street_scene.name = undefined;

//カメラ
const street_camera = new THREE.PerspectiveCamera(75, width / height, 0.01,50);
street_camera.position.set(0.1, 0, 0);
street_scene.add(street_camera);

//球の作成
let sphere;
{
    const geometry = new THREE.SphereGeometry(8, 64, 64);
    geometry.scale(-1, 1, 1);
    const loader = new THREE.TextureLoader();
    loader.load('../images/image0-0.JPG', function(texture) {
        const material =  new THREE.MeshLambertMaterial({map: texture});
        sphere = new THREE.Mesh( geometry, material);
        street_scene.add( sphere );
    });
}

//環境光源追加
{
    const light = new THREE.AmbientLight(0xFFFFFF, 1.0);
    street_scene.add(light);
}
/*↑______________________________ここまでストリートビュー用のscene______________________________________*/

//レンダラー作成
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(width, height);
renderer.setClearColor({color: 0x000000});
// renderer.shadowMap.enabled = true;
const element = renderer.domElement;

const controls = create_controls(camera,element); //control 作成
    controls.maxDistance = 220;
    controls.minDistance = 0.3;
    controls.maxPolarAngle = Math.PI/2 - 0.01;
const street_controls = create_controls(street_camera,element);
    street_controls.enableZoom = false;

function create_controls(camera,element){
    const controls = new OrbitControls(camera, element);
    controls.target.set(0, 0, 0);
    //各種設定
    controls.enableDamping = true;
    controls.enableZoom = true;
    controls.enablePan = false;
    controls.enableRotate = true;
    // controls.maxDistance = 220;
    // controls.minDistance = 0.3;
    // controls.maxPolarAngle = Math.PI/2 - 0.01;

    // 視点の速さ (timeCheck関数内も変更)
    controls.dampingFactor = 0.2;
    controls.rotateSpeed = 0.6;

    return controls;
}

stage.appendChild(element);

element.addEventListener("pointerdown", (e) => {
    // if (!check){
        const x = e.clientX - stage.offsetLeft;
        const y = e.clientY - stage.offsetTop;
        pre_click(x,y);
    // }
}, false);

element.addEventListener("pointerup", (e) => {
    // if (!check){
        const x = e.clientX - stage.offsetLeft;
        const y = e.clientY - stage.offsetTop;
        click(x,y);
    // } else check = false;
}, false);

window.addEventListener("resize", handleResize, false);

//ボタンのテクスチャ
const button_tex = new THREE.TextureLoader().load('./images/button.png');
let buttons = [];
//posiは内部ではvector
let posi = [
            //南側校舎 :[0]
                [
                    [[50,17.5,20],[50,17.5,10],[50,17.5,0],[50,17.5,-10],[50,17.5,-20],[50,17.5,-30]], //1F :[0][0]
                    [[50,31.5,20],[50,31.5,10],[50,31.5,0],[50,31.5,-10],[50,31.5,-20],[50,31.5,-30]], //2F :[0][1]
                    [[50,45.5,20],[50,45.5,10],[50,45.5,0],[50,45.5,-10],[50,45.5,-20],[50,45.5,-30]], //3F :[0][2]
                    [[50,59.5,20],[50,59.5,10],[50,59.5,0],[50,59.5,-10],[50,59.5,-20],[50,59.5,-30]], //4F :[0][3]
                    [] //屋上
                ],
            //北側校舎 :[1]
                [
                    [[-50,17.5,20],[-50,17.5,10],[-50,17.5,0],[-50,17.5,-10],[-50,17.5,-20],[-50,17.5,-30]], //1F :[1][0]
                    [[-50,31.5,20],[-50,31.5,10],[-50,31.5,0],[-50,31.5,-10],[-50,31.5,-20],[-50,31.5,-30]], //2F :[1][1]
                    [[-50,45.5,20],[-50,45.5,10],[-50,45.5,0],[-50,45.5,-10],[-50,45.5,-20],[-50,45.5,-30]], //3F :[1][2]
                    [[-50,59.5,20],[-50,59.5,10],[-50,59.5,0],[-50,59.5,-10],[-50,59.5,-20],[-50,59.5,-30]], //4F :[1][3]
                    [] //屋上
                ],
            //講堂
                [
                ],
            //体育館・食堂
                [
                ]
            ];

let posi_line = [];

const connection = [
    [0,1],
    [1,2],
    [2,3],
    [3,4],
    [4,5]
];

//posiをvectorに変換
{
    function posi_to_vec(array){
        const len = array.length;
        let ret_array = [];
        for(let i = 0; i < len; i++){
            if(typeof array[i] == "number"){ //数字の場合
                const vec = new THREE.Vector3(...array);
                posi_line.push(vec);
                return vec;
            } else { //配列の場合 再帰
                ret_array[i] = posi_to_vec(array[i]);
            }
        }
        return ret_array; //空白の場合は空配列
    }

    posi = posi_to_vec(posi);
}

let map = new Array(posi_line.length);
for (let i = 0; i < posi_line.length; ++i) map[i] = new Array();
connection.forEach((val) => {
    map[val[0]].push(val[1]);
    map[val[1]].push(val[0]);
});
console.log(map);

//obj追加
let groups = []; //こっちでgroup作ってあとでぶっこむ

const dist = 14;
const max_alt = 100;
let state = "closed";

function load_obj(mtl_file_name, obj_file_name){
    if(mtl_file_name == undefined){ //マテリアルないとき
        return new Promise((resolve,reject) => {
            const objLoader = new OBJLoader();
            objLoader.load("./models/koyo/" + obj_file_name, (root) => {
                resolve(root);
            });
        });
    } else { //マテリアルあるとき
        return new Promise((resolve,reject) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.load("./models/koyo/" + mtl_file_name, (mtl) => {
                mtl.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(mtl);
                objLoader.load("./models/koyo/" + obj_file_name, (root) => {
                    resolve(root);
                });
            });
        });
    }
}

let loaded = false;
const urls = [
    [undefined,"3dMap_south_1F.obj"],
    [undefined,"3dMap_south_2F.obj"],
    [undefined,"3dMap_south_3F.obj"],
    [undefined,"3dMap_south_4F.obj"],
    [undefined,"3dMap_south_ceiling.obj"],
    [undefined,"3dMap_north_1F.obj"],
    [undefined,"3dMap_north_2F.obj"],
    [undefined,"3dMap_north_3F.obj"],
    [undefined,"3dMap_north_4F.obj"],
    [undefined,"3dMap_north_ceiling.obj"],
];
const groups_len = urls.length;

(async () => {
    for(let i = 0; i < groups_len; i++){
        await load_obj(urls[i][0],urls[i][1]).then((root) => {
            groups[i] = root;
            groups[i].name = i; //番号
            if(0 <= i && i <= 4){
                groups[i].part_of = "south"; //建物識別
                // groups[i].position.y +=  dist*i;
                groups[i].scale.set(3,3,3);
                // groups[i].rotation.y += Math.PI * -.5;


            } else if(5 <= i && i <= 9){
                groups[i].part_of = "north";
                // groups[i].position.x += -120;
                // groups[i].position.y += dist*(i-5);
                groups[i].scale.set(3,3,3);
            }
            groups[i].ori_position = groups[i].position.clone();
            scene.add(groups[i]);
        });
    }
    loaded = true;
})();

//ボタン生成
function generate_buttons(number){ //3dモデル操作中のみ実行
    let array;
    if(0 <= number && number <= 4){
        array = posi[0][number];
    } else if(5 <= number && number <= 8){
        array = posi[1][number-5];
    }

    for(let vec of array){
        const planeGeo = new THREE.PlaneGeometry(2, 2); //サイズ
        const planeMat = new THREE.MeshPhongMaterial({map: button_tex, transparent: true});
        const mesh = new THREE.Mesh(planeGeo, planeMat);
        mesh.rotation.x = Math.PI * -.5;
        //sceneに追加
        mesh.position.copy(vec);
        mesh.name = "button";
        buttons.push(mesh);
        scene.add(mesh);
    }
}

function delete_buttons(){ //3dモデル操作中のみ実行
    const len = buttons.length;
    for(let i = 0; i < len; i++){
        scene.remove(buttons[i]);
        buttons[i].geometry.dispose();
        buttons[i].material.dispose();
        buttons[i] = undefined;
    }
    buttons = [];
}

let pre_elem_name;
let pre_posi ; //obj
function pre_click(x,y){
    pre_posi = {x: x, y: y};

    const mouse = new THREE.Vector2();
    mouse.x = (x / width) * 2 - 1;
    mouse.y = -(y / height) * 2 + 1;

    const ray = new THREE.Raycaster;
    ray.setFromCamera(mouse, camera);
    const bump = ray.intersectObjects(scene.children,true); //<=第二引数trueで下位のobjectも
    // console.log(bump[0].point);

    if(bump.length > 0) pre_elem_name = bump[0].object.parent.name;
}

//クリック時の処理
function click(x,y) {
    //objロード前return
    if(!loaded) return;
    //ドラッグとの区別
    if(Math.abs(pre_posi.x-x) > 3 || Math.abs(pre_posi.y-y) > 3) return;

    const mouse = new THREE.Vector2();
    mouse.x = (x / width) * 2 - 1;
    mouse.y = -(y / height) * 2 + 1;

    const ray = new THREE.Raycaster;
    //ここからmodeで分岐作って！！！ <====================
    ray.setFromCamera(mouse, camera);
    const bump = ray.intersectObjects(scene.children,true);
    if (bump.length != 0 && bump[0].object.parent.name == pre_elem_name && !turn_flag) {
        const obj = bump[0].object.parent;

        //青ボタンクリック
        if(bump[0].object.name == "button"){
            camera_trigger(bump[0].object.position);

        //校舎クリック
        } else if(obj.name != undefined){
            //スマホ救済用 青ボタン判定ゆるく
            const point = bump[0].point;
            let nearest = {dist: 1e9, position: undefined};
            //最も近いボタン求める
            for(let button of buttons){
                const new_dist = button.position.clone().sub(point).length();
                if(nearest.dist > new_dist){
                    nearest.dist = new_dist;
                    nearest.position = button.position;
                }
            }
            // console.log(nearest.dist);
            if(nearest.dist < 5){
                //カメラ移動
                camera_trigger(nearest.position);
            } else if(state != obj.name){ //異なる階選択時
                //校舎の上下
                if(state != "closed" && groups[state].part_of == groups[obj.name].part_of && state < obj.name){
                    //同じ校舎かつ現在より上
                    add_later = true;
                } else {
                    //現在より下か他校舎
                    delete_buttons();
                    generate_buttons(obj.name);
                    add_later = false;
                }

                state = obj.name;
                move_groups_flag = true;
            }
        //その他クリック -> closed
        } else {
            delete_buttons();
            state = "closed";
            move_groups_flag = true;
        }
    }
}

//カメラ回転関数
let turn_flag = false;
let turn_info; //obj
function camera_trigger(oav){ //3dモデル操作中のみ実行 oav:目標vector
    const ocv = camera.position;
    let acv = ocv.clone().sub(oav);
    const ohv = new THREE.Vector3(ocv.x, oav.y, ocv.z);
    let ahv = ohv.clone().sub(oav);
    const cos_theta = (ahv.clone().normalize())
                        .dot(acv.clone().normalize());
    let theta = Math.acos(cos_theta); //thetaはラジアン
    const size = acv.clone().length();
    if(oav.y > ocv.y) theta *= -1;
    ahv.normalize();

    //移行用
    controls.enableRotate = false;
    controls.enableZoom = false;

    turn_flag = true;
    turn_info = {ahv: ahv, oav: oav, theta: theta, size: size, cnt1: 1, cnt2: 0, rad: Math.PI*0.25};
}

function move_camera(){ //3dの時のみ実行
    if(!turn_flag) return;

    let diff1;
    //初め=>45度
    if(turn_info.rad) diff1 = ease_diff(turn_info.theta, turn_info.rad, 0.01);
    //45度=>0度
    else{
        diff1 = (turn_info.theta - Math.PI*0.25 -0.1)*0.012;
        if(turn_info.theta + diff1 < 0) diff1 = 0;
    }

    const diff2 = ease_diff(turn_info.cnt1, 0, 0.005);
    const diff3 = ease_diff(turn_info.cnt2, 1, 0.01);

    if(turn_info.rad){
        turn_info.theta += diff1;
    } else {
        turn_info.theta += diff1;
    }
    turn_info.cnt1 += diff2; // 0 <= cnt1,cnt2 <= 1
    turn_info.cnt2 += diff3;

    if(!diff1 && turn_info.rad){
        turn_info.rad = 0;
    } else if(!(diff1 || diff2 || diff3)){
        //終了
        // controls.enableRotate = true;
        // controls.enableZoom = true;
        turn_flag = false;
        console.log("終了");
        mode = "street";
        console.log(street_camera.position);
        // street_camera.position.set(0.1,0,0);
        return;
    }

    //カメラ自体の位置
    const yv = new THREE.Vector3(0,1,0)
                .multiplyScalar(Math.sin(turn_info.theta));
    const xzv = turn_info.ahv.clone()
                .multiplyScalar(Math.cos(turn_info.theta));
    const anv = yv.add(xzv).multiplyScalar(turn_info.size* (turn_info.cnt1+(1-turn_info.cnt1)*0.02) ); //調整 真上防止
    camera.position.copy( anv.add(turn_info.oav).add(new THREE.Vector3(0,0.1,0)) ); //めり込み防止で足す

    //target 移動
    // console.log(street_camera.position);
    controls.target.copy(turn_info.oav.clone()
                        .multiplyScalar( turn_info.cnt2 )
                        .add(new THREE.Vector3(0,0.1,0))); //カメラと同様に足して平行に
}

let move_groups_flag = false; //move_groupsを回すフラグ
let add_later = false; //groupを動かし終わってからの動作のフラグ
function move_groups(){ //3dモデル操作中のみ実行
    if(!move_groups_flag) return;

    //上に行くものの中で最小の番号
    let num;
    if(state == "closed") num = groups_len;
    else num = state+1;

    //移動
    let up = false, down = false;
    for(let i = groups_len-1; i >= 1; i--){
        if(state == "closed" || groups[state].part_of != groups[i].part_of){ //非選択又は別校舎
            if(groups[i].position.y > groups[i].ori_position.y){
                down = true;
                groups[i].position.y += ease_diff(groups[i].position.y, groups[i].ori_position.y, 0.08);
            }
        } else if(i >= num && groups[i].position.y < max_alt+groups[i].ori_position.y){ //同校舎かつ上がる階
            up = true;
            groups[i].position.y += ease_diff(groups[i].position.y, max_alt+groups[i].ori_position.y, 0.05);
        } else if(i < num && groups[i].position.y > groups[i].ori_position.y){ //同校舎かつ下がる階
            down = true;
            groups[i].position.y += ease_diff(groups[i].position.y, groups[i].ori_position.y, 0.08);
        }
    }

    if(!up && !down){ //移動終了時の処理
        move_groups_flag = false;
        if(add_later){
            delete_buttons();
            generate_buttons(state);
            add_later = false;
        }
        // console.log(buttons);
    }
}

function ease_diff(cur,goal,speed){ //返り値はイージングされた速度の変化量
    speed *= ratio;
    const a = (goal-cur)*speed;
    if(a >= 0){
        return Math.min( a+speed*0.3, goal-cur );
    } else {
        return Math.max( a-speed*0.3, goal-cur );
    }
}

function handleResize() {
    width = window.innerWidth;
    height = window.innerHeight;
    //レンダラーサイズ変更
    renderer.setSize(width, height);
    //カメラアスペクト比変更
    if(mode == "3d"){ //3dモデル操作中
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    } else { //streetview操作中
        street_camera.aspect = width / height;
        street_camera.updateProjectionMatrix();
    }
}

let last_time = 0;
let ratio = 1;
let true_cnt = 0;
let false_cnt = 0;
let limited = false;
function timeCheck() { //20fps未満は解像度下げる
    const fps60 = 1000 / 60;
    const timed = new Date().getTime() - last_time;
    ratio = timed / fps60;
    if(ratio > 3){
        true_cnt++;
        if(true_cnt > 10){
            const cur_pixelRatio = window.devicePixelRatio;
            if(cur_pixelRatio > 1) renderer.setPixelRatio(1);
            else renderer.setPixelRatio(0.5);

            if(mode == "3d") controls.rotateSpeed = 0.6*3; //視点の速さ 遅れ修正
            else street_controls.rotateSpeed = 0.6*3;

            true_cnt = 0; false_cnt = 0;
            limited = true;
        }
    } else {
        false_cnt++;
        if(false_cnt > 10){
            renderer.setPixelRatio(window.devicePixelRatio);
            true_cnt = 0; false_cnt = 0;
            limited = false;
        }
    }
}

let render_cnt = 1;
function render() {
    requestAnimationFrame(render);
    if(mode == "3d"){ //3dモデル操作中
        move_camera();
        move_groups();
        renderer.render(scene, camera);
        controls.update();
    } else { //street view 中
        renderer.render(street_scene, street_camera);
        street_controls.update();
    }

    timeCheck();
    if(limited){ //30fps
        render_cnt *= -1;
        if(render_cnt > 0) return;
    }
    last_time = new Date().getTime();
}

requestAnimationFrame(render);
</script>
<style>
    body, html {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }
    #stage{
        width: 100%;
        height: 100%;
        display: block;
    }
</style>
</html>
