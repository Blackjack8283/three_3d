<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
	<meta charset="UTF-8">
	<title>3dテスト</title>
</head>
<body>
<!-- 	<canvas id="c"></canvas> -->
</body>
<script type="module">
import * as THREE from '../three/build/three.module.js';
import {OrbitControls} from '../three/examples/jsm/controls/OrbitControls.js';
import {OBJLoader} from '../three/examples/jsm/loaders/OBJLoader.js';
import {MTLLoader} from '../three/examples/jsm/loaders/MTLLoader.js';

let width = window.innerWidth;
let height = window.innerHeight;

document.body.insertAdjacentHTML("afterbegin","<div id='stage'></div>");
const stage = document.getElementById("stage");
// const canvas = document.querySelector('#c');
const scene = new THREE.Scene();
scene.background = new THREE.Color('skyblue');
scene.name = undefined;

const camera = new THREE.PerspectiveCamera(75, width/height, 0.01, 1000);
camera.position.set(0, 100, 80);
scene.add(camera);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(width, height);
renderer.setClearColor({color: 0x000000});
// renderer.shadowMap.enabled = true;
const element = renderer.domElement;

const controls = new OrbitControls(camera, element);
controls.target.set(0, 0, 0);
//各種設定
controls.enableDamping = true;
controls.enableZoom = true;
controls.enablePan = false;
controls.enableRotate = true;
controls.maxDistance = 220;
controls.minDistance = 0.3;
controls.maxPolarAngle = Math.PI/2 - 0.01;

// 視点の速さ　(timeCheck関数内も)
controls.dampingFactor = 0.2;
controls.rotateSpeed = 0.6;

stage.appendChild(element);

element.addEventListener("pointerdown", (e) => {
    // if (!check){
        const x = e.clientX - stage.offsetLeft;
        const y = e.clientY - stage.offsetTop;
        pre_click(x,y);
    // }
}, false);

element.addEventListener("pointerup", (e) => {
    // if (!check){
        const x = e.clientX - stage.offsetLeft;
        const y = e.clientY - stage.offsetTop;
        click(x,y);
    // } else check = false;
}, false);

window.addEventListener("resize", handleResize, false);

//地面
{
    const planeSize = 512;

    //画像
    const texture = new THREE.TextureLoader().load('./images/grass.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.LinearMipmapLinearFilter;
    //planeSize/2回リピート
    const repeats = planeSize / 64;
    texture.repeat.set(repeats, repeats);

    //平面のジオメトリ
    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    //マテリアル
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide //両面描画
    });
    //合成してメッシュ
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    //sceneに追加
    scene.add(mesh);
}

//半球光源 追加
{
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 0.8;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
}

//平行光源　追加
{
    const color = 0xFFFFFF;
    const intensity = 0.8;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(5, 10, 2);
    scene.add(light);
    // scene.add(light.target);
}

//外側の球
{
    const loader = new THREE.TextureLoader();
    loader.load('https://82mou.github.io/threejs/img/earth.jpg', function(texture) {
        const geometry = new THREE.SphereGeometry(250, 32, 32);
        geometry.scale(-1, 1, 1);
        const material =  new THREE.MeshLambertMaterial({map: texture});
        const sphere = new THREE.Mesh( geometry, material);
        scene.add( sphere );
    });
}

//ボタン　テクスチャ
const button_tex = new THREE.TextureLoader().load('./images/button.png');
let buttons = [];
//posiは内部ではvector
let posi = [
            //南側校舎 :[0]
                [
                    [], //1F :[0][0]
                    [], //2F :[0][1]
                    [], //3F :[0][2]
                    [[50,75,20]]  //4F :[0][3]
                ],
            //北側校舎 :[1]
                [
                    [], //1F :[1][0]
                    [], //2F :[1][1]
                    [], //3F :[1][2]
                    []  //4F :[1][3]
                ],
            //講堂
                [
                ],
            //体育館・食堂
                [
                ]
            ];

//posiをvectorに変換
function posi_to_vec(array){
    const len = array.length;
    let ret_array = [];
    for(let i = 0; i < len; i++){
        if(typeof array[i] == "number"){ //数字の場合
            return new THREE.Vector3(...array);
        } else { //配列の場合　再帰
            ret_array[i] = posi_to_vec(array[i]);
        }
    }
    return ret_array; //空白の場合は空配列
}

posi = posi_to_vec(posi);
console.log(posi);

generate_buttons(posi[0][3]);

//ボタン生成
function generate_buttons(array){
    for(let vec of array){
        const planeGeo = new THREE.PlaneGeometry(2, 2); //サイズ
        const planeMat = new THREE.MeshPhongMaterial({map: button_tex, transparent: true});
        const mesh = new THREE.Mesh(planeGeo, planeMat);
        mesh.rotation.x = Math.PI * -.5;
        //sceneに追加
        mesh.position.copy(vec);
        mesh.name = "button";
        buttons.push(mesh);
        scene.add(mesh);
    }
}

// setTimeout(delete_buttons,1000);
function delete_buttons(){
    const len = buttons.length;
    for(let i = 0; i < len; i++){
        scene.remove(buttons[i]);
        buttons[i].geometry.dispose();
        buttons[i].material.dispose();
        buttons[i] = undefined;
    }
    buttons = [];
}

//ごみ
function delete_mesh(array){
    for(let mesh of array){
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        return undefined;
    }
}

//obj追加
const groups_len = 5;
let groups = []; //こっちでgroup作ってあとでぶっこむ
for(let i = 0; i < groups_len; i++){
    groups[i] = new THREE.Group();
}

const dist = 14;
const max_alt = 80;
let state = "closed";
{
    const mtlLoader = new MTLLoader();
    mtlLoader.load('./models/koyo/koyo.mtl', (mtl) => {
        mtl.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(mtl);
        objLoader.load('./models/koyo/koyo.obj', (root) => {
            for(let i = 0; i < groups_len; i++){
                const new_root = root.clone();
                new_root.name = String(i);
                groups[i].add(new_root);
                groups[i].scale.set(0.5,0.5,0.5);
                groups[i].position.y +=  dist*i; //非同期注意
                scene.add(groups[i]);
            }
        });
    });
}


let pre_elem_name;
let pre_posi ; //obj
function pre_click(x,y){
    pre_posi = {x: x, y: y};

    const mouse = new THREE.Vector2();
    mouse.x = (x / width) * 2 - 1;
    mouse.y = -(y / height) * 2 + 1;

    const ray = new THREE.Raycaster;
    ray.setFromCamera(mouse, camera);
    const bump = ray.intersectObjects(scene.children,true); //<=第二引数trueで下位のobjectも
    // console.log(bump[0].point);

    if(bump.length > 0) pre_elem_name = bump[0].object.parent.name;
}

function click(x,y) {
    if(Math.abs(pre_posi.x-x) > 3 || Math.abs(pre_posi.y-y) > 3) return;

    const mouse = new THREE.Vector2();
    mouse.x = (x / width) * 2 - 1;
    mouse.y = -(y / height) * 2 + 1;

    const ray = new THREE.Raycaster;
    ray.setFromCamera(mouse, camera);
    const bump = ray.intersectObjects(scene.children,true);
    if (bump.length != 0 && bump[0].object.parent.name == pre_elem_name && !turn_flag) {
        const obj = bump[0].object.parent;
        //青ボタン
        if(bump[0].object.name == "button"){
            camera_trigger(bump[0].point, camera.position);

        //校舎クリック
        } else if(obj.name != undefined){
            state = obj.name; //階の上下

        //その他クリック
        } else {
            state = "closed";
        }
        console.log(bump[0].object.name);
    }
}

//カメラ回転関数
let turn_flag = false;
let turn_info; //obj
function camera_trigger(oav, ocv){ //目標v, カメラv
    let acv = ocv.clone().sub(oav);
    const ohv = new THREE.Vector3(ocv.x, oav.y, ocv.z);
    let ahv = ohv.clone().sub(oav);
    const cos_theta = (ahv.clone().normalize())
                        .dot(acv.clone().normalize());
    let theta = Math.acos(cos_theta); //thetaはラジアン
    const size = acv.clone().length();
    if(oav.y > ocv.y) theta *= -1;
    ahv.normalize();

    //移行用
    controls.enableRotate = false;
    controls.enableZoom = false;

    turn_flag = true;
    turn_info = {ahv: ahv, oav: oav, targetv: controls.target.clone(), theta: theta, size: size, cnt1: 1, cnt2: 0, rad: Math.PI*0.25};
}

function move_camera(){
    if(!turn_flag) return;

    let diff1;
    //初め=>45度
    if(turn_info.rad) diff1 = ease_diff(turn_info.theta, turn_info.rad, 0.01);
    //45度=>0度
    else{
        diff1 = (turn_info.theta - Math.PI*0.25 -0.1)*0.012;
        if(turn_info.theta + diff1 < 0) diff1 = 0;
    }

    const diff2 = ease_diff(turn_info.cnt1, 0, 0.005);
    const diff3 = ease_diff(turn_info.cnt2, 1, 0.01);

    if(turn_info.rad){
        turn_info.theta += diff1;
    } else {
        turn_info.theta += diff1;
    }
    turn_info.cnt1 += diff2; // 0 <= cnt1,cnt2 <= 1
    turn_info.cnt2 += diff3;

    if(!diff1 && turn_info.rad){
        turn_info.rad = 0;
    } else if(!(diff1 || diff2 || diff3)){
        //終了
        controls.enableRotate = true;
        controls.enableZoom = true;
        turn_flag = false;
        return;
    }

    //カメラ自体の位置
    const yv = new THREE.Vector3(0,1,0)
                .multiplyScalar(Math.sin(turn_info.theta));
    const xzv = turn_info.ahv.clone()
                .multiplyScalar(Math.cos(turn_info.theta));
    const anv = yv.add(xzv).multiplyScalar(turn_info.size* (turn_info.cnt1+(1-turn_info.cnt1)*0.02) ); //調整　真上防止
    camera.position.copy( anv.add(turn_info.oav).add(new THREE.Vector3(0,0.1,0)) ); //めり込み防止で足す

    //target 移動

    controls.target.copy(turn_info.oav.clone().sub(turn_info.targetv)
                        .multiplyScalar( turn_info.cnt2 )
                        .add(turn_info.targetv))
                        .add(new THREE.Vector3(0,0.1,0)); //カメラと同様に足して平行に
}

const speed = 0.1;
function move_groups(){
    if(state == "closed"){ //閉まった状態　最上階と区別のため
        let diff = 0;
        for(let i = groups_len-1; i >= 1; i--){
            if(!diff) diff = ease_diff(groups[i].position.y, dist*i, speed*ratio);
            if(groups[i].position.y > dist*i){ //関係ないのを巻き込まない
                groups[i].position.y += diff;
            }
        }
    } else { //x階部分が見える
        const num = Number(state)+1;
        for(let i = groups_len-1; i >= 1; i--){
            if(i >= num && groups[i].position.y < max_alt+dist*(i-1)){
                groups[i].position.y += ease_diff(groups[i].position.y, max_alt+dist*(i-1), speed*ratio);
            } else if(i < num && groups[i].position.y > dist*i){
                groups[i].position.y += ease_diff(groups[i].position.y, dist*i, speed*ratio);
            }
        }
    }
}

function ease_diff(cur,goal,speed){ //返り値はイージングされた速度のデルタ
    const a = (goal-cur)*speed;
    if(a >= 0){
        return Math.min( a+speed*0.3, goal-cur );
    } else {
        return Math.max( a-speed*0.3, goal-cur );
    }
}

function handleResize() {
    width = window.innerWidth;
    height = window.innerHeight;
    //レンダラーサイズ変更
    renderer.setSize(width, height);
    //カメラアスペクト比変更
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
}

let last_time = 0;
let ratio = 1;
let true_cnt = 0;
let false_cnt = 0;
let limited = false;
function timeCheck() { //20fps未満は解像度下げる
    const fps60 = 1000 / 60;
    const timed = new Date().getTime() - last_time;
    ratio = timed / fps60;
    if(ratio > 3){
        true_cnt++;
        if(true_cnt > 10){
            const cur_pixelRatio = window.devicePixelRatio;
            if(cur_pixelRatio > 1) renderer.setPixelRatio(1);
            else renderer.setPixelRatio(0.5);
            controls.rotateSpeed = 0.6*3; //視点の速さ　遅れ修正

            true_cnt = 0; false_cnt = 0;
            limited = true;
        }
    } else {
        false_cnt++;
        if(false_cnt > 10){
            renderer.setPixelRatio(window.devicePixelRatio);
            true_cnt = 0; false_cnt = 0;
            limited = false;
        }
    }
    last_time = new Date().getTime();
}

let render_cnt = 1;
function render() {
    requestAnimationFrame(render);

    timeCheck();
    if(limited){ //30fps
        render_cnt *= -1;
        if(render_cnt > 0) return;
    }
    move_camera();
    move_groups();
    renderer.render(scene, camera);
    controls.update();
}

requestAnimationFrame(render);
</script>
<style>
    body, html {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }
    #stage{
        width: 100%;
        height: 100%;
        display: block;
    }
</style>
</html>
