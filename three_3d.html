<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
	<meta charset="UTF-8">
	<title>3dテスト</title>
</head>
<body>
<!-- 	<canvas id="c"></canvas> -->
</body>
<script type="module">
import * as THREE from '../three/build/three.module.js';
import {OrbitControls} from '../three/examples/jsm/controls/OrbitControls.js';
import {OBJLoader} from '../three/examples/jsm/loaders/OBJLoader.js';
import {MTLLoader} from '../three/examples/jsm/loaders/MTLLoader.js';

let width = window.innerWidth;
let height = window.innerHeight;

document.body.insertAdjacentHTML("afterbegin","<div id='stage'></div>");
const stage = document.getElementById("stage");
// const canvas = document.querySelector('#c');
const scene = new THREE.Scene();
scene.background = new THREE.Color('skyblue');
scene.name = undefined;

const camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
camera.position.set(0, 40, 40);
scene.add(camera);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(width, height);
renderer.setClearColor({color: 0x000000});
// renderer.shadowMap.enabled = true;
const element = renderer.domElement;

const controls = new OrbitControls(camera, element);
controls.target.set(0, 0, 0);
//各種設定
controls.enableDamping = true;
controls.enableZoom = true;
controls.enablePan = false;
controls.enableRotate = true;
controls.maxDistance = 200;
controls.minDistance = 0.3;
controls.maxPolarAngle = Math.PI/2 - 0.01;

// 視点の速さ　(timeCheck関数内も)
controls.dampingFactor = 0.2;
controls.rotateSpeed = 0.6;

stage.appendChild(element);

//クリック
// let check = false;
// element.addEventListener("touchstart", (e) => {
//     check = true;
//     const x = e.changedTouches[0].pageX - stage.offsetLeft;
//     const y = e.changedTouches[0].pageY - stage.offsetTop;
//     pre_click(x,y);
//     console.log("phone");
// }, false);

// element.addEventListener("touchend", (e) => {
//     const x = e.changedTouches[0].pageX - stage.offsetLeft;
//     const y = e.changedTouches[0].pageY - stage.offsetTop;
//     click(x,y);
// }, false);

element.addEventListener("pointerdown", (e) => {
    // if (!check){
        const x = e.clientX - stage.offsetLeft;
        const y = e.clientY - stage.offsetTop;
        pre_click(x,y);
    // }
}, false);

element.addEventListener("pointerup", (e) => {
    // if (!check){
        const x = e.clientX - stage.offsetLeft;
        const y = e.clientY - stage.offsetTop;
        click(x,y);
    // } else check = false;
}, false);

window.addEventListener("resize", handleResize, false);

//平面
{
    const planeSize = 512;

    const loader = new THREE.TextureLoader();
    //画像
    const texture = loader.load('./images/grass.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    //planeSize/2回リピート
    const repeats = planeSize / 64;
    texture.repeat.set(repeats, repeats);

    //平面のジオメトリ
    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    //マテリアル
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    //合成してメッシュ
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    //sceneに追加
    scene.add(mesh);
}

//半球光源 追加
{
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 0.8;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
}

//平行光源　追加
{
    const color = 0xFFFFFF;
    const intensity = 0.8;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(5, 10, 2);
    scene.add(light);
    // scene.add(light.target);
}

//外側の球
{
    const loader = new THREE.TextureLoader();
    loader.load('https://82mou.github.io/threejs/img/earth.jpg', function(texture) {
        const geometry = new THREE.SphereGeometry(200, 32, 32);
        geometry.scale(-1, 1, 1);
        const material =  new THREE.MeshLambertMaterial({map: texture});
        const sphere = new THREE.Mesh( geometry, material);
        scene.add( sphere );
    });

    // const geometry = new THREE.SphereGeometry( 100, 32, 32 );
    // const material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
    // const sphere = new THREE.Mesh( geometry, material );
    // scene.add( sphere );
}

//obj追加
const groups_len = 5;
let groups = []; //こっちでgroup作ってあとでぶっこむ
for(let i = 0; i < groups_len; i++){
    groups[i] = new THREE.Group();
}

const dist = 5;
const max_alt = 30;
let state = "closed";
{
    const mtlLoader = new MTLLoader();
    mtlLoader.load('./models/koyo/koyo.mtl', (mtl) => {
        mtl.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(mtl);
        objLoader.load('./models/koyo/koyo.obj', (root) => {
            for(let i = 0; i < groups_len; i++){
                const new_root = root.clone();
                new_root.name = String(i);
                groups[i].add(new_root);
                groups[i].scale.set(0.15,0.15,0.15);
                groups[i].position.y +=  dist*i;
                scene.add(groups[i]);
            }
        });
    });
}


let pre_elem_name;
function pre_click(x,y){
    const mouse = new THREE.Vector2();
    mouse.x = (x / width) * 2 - 1;
    mouse.y = -(y / height) * 2 + 1;

    const ray = new THREE.Raycaster;
    ray.setFromCamera(mouse, camera);
    const bump = ray.intersectObjects(scene.children,true); //<=第二引数trueで下位のobjectも
    // console.log(bump[0].point);

    if(bump.length > 0) pre_elem_name = bump[0].object.parent.name;
}

function click(x,y) {
    const mouse = new THREE.Vector2();
    mouse.x = (x / width) * 2 - 1;
    mouse.y = -(y / height) * 2 + 1;

    const ray = new THREE.Raycaster;
    ray.setFromCamera(mouse, camera);
    const bump = ray.intersectObjects(scene.children,true);
    if (bump.length != 0 && bump[0].object.parent.name == pre_elem_name) {
        const obj = bump[0].object.parent;
        if(obj.name != undefined){
            if(state == obj.name) camera_trigger(bump[0].point, camera.position);
            else state = obj.name;
        } else { //テスト用分岐　カメラ回転関数へ
            state = "closed";
        }
    }
}

//カメラ回転関数
let turn_flag = false;
let turn_info; //{ahv: undefined, oav: undefined ,theta: undefined, size: undefined, cnt:0}; //acv, ahv, theta, dist, count
function camera_trigger(oav, ocv){ //目標v, カメラv
    // console.log(oav,ocv);
    let acv = ocv.clone().sub(oav);
    const ohv = new THREE.Vector3(ocv.x, oav.y, ocv.z);
    let ahv = ohv.clone().sub(oav);
    const cos_theta = (ahv.clone().normalize())
                        .dot(acv.clone().normalize());
    let theta = Math.acos(cos_theta); //ラジアンじゃ
    const size = acv.clone().length();
    if(oav.y > ocv.y) theta *= -1;
    ahv.normalize();

    //移行用
    controls.enableRotate = false;
    controls.enableZoom = false;

    turn_flag = true;
    turn_info = {ahv: ahv, oav: oav, targetv: controls.target.clone(), theta: theta, size: size, cnt1: 1, cnt2: 0, rad: Math.PI*0.25};
}

function move_camera(){
    if(!turn_flag) return;

    let diff1;
    //初め=>45度
    if(turn_info.rad) diff1 = ease_diff(turn_info.theta, turn_info.rad, 0.01);
    //45度=>0度
    else{
        diff1 = (turn_info.theta - Math.PI*0.25 -0.1)*0.015;
        if(turn_info.theta + diff1 < 0) diff1 = 0;
    }

    const diff2 = ease_diff(turn_info.cnt1, 0, 0.005);
    const diff3 = ease_diff(turn_info.cnt2, 1, 0.01);

    if(turn_info.rad){
        turn_info.theta += diff1;
    } else {
        turn_info.theta += diff1;
    }
    turn_info.cnt1 += diff2; // 0 <= cnt1,cnt2 <= 1
    turn_info.cnt2 += diff3;

    if(!diff1 && turn_info.rad){
        turn_info.rad = 0;
    } else if(!(diff1 || diff2 || diff3)){
        //終了
        controls.enableRotate = true;
        controls.enableZoom = true;
        turn_flag = false;
        return;
    }

    //カメラ自体の位置
    const yv = new THREE.Vector3(0,1,0)
                .multiplyScalar(Math.sin(turn_info.theta));
    const xzv = turn_info.ahv.clone()
                .multiplyScalar(Math.cos(turn_info.theta));
    const anv = yv.add(xzv).multiplyScalar(turn_info.size* (turn_info.cnt1+(1-turn_info.cnt1)*0.02) ); //調整　真上防止
    camera.position.copy( anv.add(turn_info.oav).add(new THREE.Vector3(0,1,0)) );

    //target 移動

    controls.target.copy(turn_info.oav.clone().sub(turn_info.targetv)
                        .multiplyScalar( turn_info.cnt2 )
                        .add(turn_info.targetv));
}

const speed = 0.1;
function move_groups(){
    if(state == "closed"){ //閉める
        for(let i = groups_len-1; i >= 1; i--){
            if(groups[i].position.y > dist*i){
                groups[i].position.y += ease_diff(groups[i].position.y, dist*i, speed*ratio);
            }
        }
    } else { //x階部分が見える
        const num = Number(state)+1;
        for(let i = groups_len-1; i >= 1; i--){
            if(i >= num && groups[i].position.y < max_alt+dist*(i-1)){
                groups[i].position.y += ease_diff(groups[i].position.y, max_alt+dist*(i-1), speed*ratio);
            } else if(i < num && groups[i].position.y > dist*i){
                groups[i].position.y += ease_diff(groups[i].position.y, dist*i, speed*ratio);
            }
        }
    }
}

function ease_diff(cur,goal,speed){ //返り値はイージングされた速度のデルタ
    const a = (goal-cur)*speed;
    if(a >= 0){
        return Math.min( a+speed*0.3, goal-cur );
    } else {
        return Math.max( a-speed*0.3, goal-cur );
    }
}

function handleResize() {
    width = window.innerWidth;
    height = window.innerHeight;
    console.log(width,height);
    //レンダラーサイズ変更
    // renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);
    // console.log(renderer);
    //カメラアスペクト比変更
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
}

let last_time = 0;
let ratio = 1;
let true_cnt = 0;
let false_cnt = 0;
let limited = false;
function timeCheck() { //20fps未満は解像度下げる
    const fps60 = 1000 / 60;
    const timed = new Date().getTime() - last_time;
    ratio = timed / fps60;
    if(ratio > 3){
        true_cnt++;
        if(true_cnt > 10){
            const cur_pixelRatio = window.devicePixelRatio;
            if(cur_pixelRatio > 1) renderer.setPixelRatio(1);
            else renderer.setPixelRatio(0.5);
            controls.rotateSpeed = 0.6*3; //視点の速さ　遅れ修正

            true_cnt = 0; false_cnt = 0;
            limited = true;
        }
    } else {
        false_cnt++;
        if(false_cnt > 10){
            renderer.setPixelRatio(window.devicePixelRatio);
            true_cnt = 0; false_cnt = 0;
            limited = false;
        }
    }
    last_time = new Date().getTime();
}

let render_cnt = 1;
function render() {
    requestAnimationFrame(render);

    timeCheck();
    if(limited){ //30fps
        render_cnt *= -1;
        if(render_cnt > 0) return;
    }
    // camera.lookAt(new THREE.Vector3(0, 10, 0));
    move_camera();
    move_groups();
    renderer.render(scene, camera);
    controls.update();
}

requestAnimationFrame(render);
</script>
<style>
    body, html {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }
    #stage{
        width: 100%;
        height: 100%;
        display: block;
    }
</style>
</html>
